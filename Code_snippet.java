@GetMapping
public ResponseEntity<?> getAllStories(
        @RequestParam(defaultValue = "0") int page, 
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "createDate,desc") String[] sort,
        @RequestParam(required = false) String status,
        @RequestParam(required = false) String assignee) {
    
    // Build Specification based on filter parameters
    Specification<Story> spec = Specification.where(null);
    
    if (status != null) {
        spec = spec.and((root, query, criteriaBuilder) -> 
            criteriaBuilder.equal(root.get("status"), status));
    }
    
    if (assignee != null) {
        spec = spec.and((root, query, criteriaBuilder) -> 
            criteriaBuilder.equal(root.get("assignee"), assignee));
    }

    Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createDate"));
    Page<Story> storiesPage = storyRepository.findAll(spec, pageable);
    return ResponseEntity.ok(storiesPage);
}

// Repository Extension:

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface StoryRepository extends JpaRepository<Story, StoryId>, JpaSpecificationExecutor<Story> {
    // Additional query methods (if any) can be defined here
}

// Add HATEOAS Dependencies:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

//Modify the Controller:

import org.springframework.hateoas.EntityModel;
import org.springframework.hateoas.PagedModel;
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;

@GetMapping
public ResponseEntity<PagedModel<EntityModel<Story>>> getAllStories(
        @RequestParam(defaultValue = "0") int page, 
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "createDate,desc") String[] sort) {
    
    if (page < 0 || size <= 0) {
        throw new IllegalArgumentException("Invalid pagination parameters: 'page' must be >= 0 and 'size' must be > 0.");
    }

    Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createDate"));
    Page<Story> storiesPage = storyService.getAllStories(pageable);

    PagedModel<EntityModel<Story>> pagedModel = PagedModel.of(
        storiesPage.getContent().stream()
            .map(story -> EntityModel.of(story,
                WebMvcLinkBuilder.linkTo(WebMvcLinkBuilder.methodOn(StoryController.class).getStory(story.getInstance(), story.getKey())).withSelfRel()))
            .collect(Collectors.toList()),
        new PagedModel.PageMetadata(
            storiesPage.getSize(),
            storiesPage.getNumber(),
            storiesPage.getTotalElements(),
            storiesPage.getTotalPages()
        )
    );

    return ResponseEntity.ok(pagedModel);
}


CREATE TABLE GET_REQUEST_LOG (
    LOG_ID          NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TIMESTAMP       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    HTTP_METHOD     VARCHAR2(10) DEFAULT 'GET' NOT NULL,
    ENDPOINT        VARCHAR2(255) NOT NULL,
    QUERY_PARAMS    CLOB,
    CLIENT_IP       VARCHAR2(45), -- Supports IPv6
    USER_ID         VARCHAR2(100),
    RESPONSE_STATUS NUMBER,
    RESPONSE_TIME   NUMBER, -- In milliseconds
    USER_AGENT      VARCHAR2(500),
    REFERER         VARCHAR2(500)
);

 //Creating the Entity
// GetRequestLog.java

package com.yourcompany.storyapi.model;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "GET_REQUEST_LOG")
public class GetRequestLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "LOG_ID")
    private Long logId;

    @Column(name = "TIMESTAMP", nullable = false)
    private LocalDateTime timestamp;

    @Column(name = "HTTP_METHOD", nullable = false, length = 10)
    private String httpMethod = "GET";

    @Column(name = "ENDPOINT", nullable = false, length = 255)
    private String endpoint;

    @Lob
    @Column(name = "QUERY_PARAMS")
    private String queryParams;

    @Column(name = "CLIENT_IP", length = 45)
    private String clientIp;

    @Column(name = "USER_ID", length = 100)
    private String userId;

    @Column(name = "RESPONSE_STATUS")
    private Integer responseStatus;

    @Column(name = "RESPONSE_TIME")
    private Long responseTime; // In milliseconds

    @Column(name = "USER_AGENT", length = 500)
    private String userAgent;

    @Column(name = "REFERER", length = 500)
    private String referer;

    // Constructors
    public GetRequestLog() {
        this.timestamp = LocalDateTime.now();
    }

    // Getters and Setters
    // ...

    // For brevity, getters and setters are omitted. Use Lombok or generate them.
}

// GetRequestLogRepository.java

package com.yourcompany.storyapi.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.yourcompany.storyapi.model.GetRequestLog;

@Repository
public interface GetRequestLogRepository extends JpaRepository<GetRequestLog, Long> {
    // Additional query methods can be defined here if needed
}


// GetRequestLoggingFilter.java 
// (Using a Servlet Filter is an effective way to intercept all incoming HTTP requests. Here's how to implement it)

package com.yourcompany.storyapi.filter;

import com.yourcompany.storyapi.model.GetRequestLog;
import com.yourcompany.storyapi.repository.GetRequestLogRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class GetRequestLoggingFilter implements Filter {

    @Autowired
    private GetRequestLogRepository logRepository;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization logic if needed
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        long startTime = System.currentTimeMillis();

        // Proceed with the next filter or the target resource
        chain.doFilter(request, response);

        long duration = System.currentTimeMillis() - startTime;

        // Only log GET requests
        if (request instanceof HttpServletRequest) {
            HttpServletRequest httpRequest = (HttpServletRequest) request;

            if ("GET".equalsIgnoreCase(httpRequest.getMethod())) {
                HttpServletResponse httpResponse = (HttpServletResponse) response;

                GetRequestLog log = new GetRequestLog();
                log.setEndpoint(httpRequest.getRequestURI());
                log.setQueryParams(httpRequest.getQueryString());
                log.setClientIp(getClientIp(httpRequest));
                log.setUserAgent(httpRequest.getHeader("User-Agent"));
                log.setReferer(httpRequest.getHeader("Referer"));
                log.setResponseStatus(httpResponse.getStatus());
                log.setResponseTime(duration);

                // Assuming authentication is used; adjust accordingly  -  remove the line for unauthenticated
                if (httpRequest.getUserPrincipal() != null) {
                    log.setUserId(httpRequest.getUserPrincipal().getName());
                }

                // Save the log entry
                logRepository.save(log);
            }
        }
    }

    @Override
    public void destroy() {
        // Cleanup logic if needed
    }

    /**
     * Helper method to extract client IP address.
     * Considers X-Forwarded-For header in case of proxies.
     */
    private String getClientIp(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null){
            return request.getRemoteAddr();
        }
        return xfHeader.split(",")[0];
    }
}

// Add @EnableAsync

// GetRequestLogService.java

package com.yourcompany.storyapi.service;

import com.yourcompany.storyapi.model.GetRequestLog;
import com.yourcompany.storyapi.repository.GetRequestLogRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

@Service
public class GetRequestLogService {

    @Autowired
    private GetRequestLogRepository logRepository;

    @Async
    public void saveLog(GetRequestLog log) {
        logRepository.save(log);
    }
}

// Update the Filter to Use the Service, GetRequestLoggingFilter.java

package com.yourcompany.storyapi.filter;

import com.yourcompany.storyapi.model.GetRequestLog;
import com.yourcompany.storyapi.service.GetRequestLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class GetRequestLoggingFilter implements Filter {

    @Autowired
    private GetRequestLogService logService;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // Initialization logic if needed
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        long startTime = System.currentTimeMillis();

        // Proceed with the next filter or the target resource
        chain.doFilter(request, response);

        long duration = System.currentTimeMillis() - startTime;

        // Only log GET requests
        if (request instanceof HttpServletRequest) {
            HttpServletRequest httpRequest = (HttpServletRequest) request;

            if ("GET".equalsIgnoreCase(httpRequest.getMethod())) {
				String uri = httpRequest.getRequestURI();
				if (!uri.startsWith("/health") && !uri.startsWith("/static")) {
                HttpServletResponse httpResponse = (HttpServletResponse) response;

                GetRequestLog log = new GetRequestLog();
                log.setEndpoint(httpRequest.getRequestURI());
                log.setQueryParams(httpRequest.getQueryString());
                log.setClientIp(getClientIp(httpRequest));
                log.setUserAgent(httpRequest.getHeader("User-Agent"));
                log.setReferer(httpRequest.getHeader("Referer"));
                log.setResponseStatus(httpResponse.getStatus());
                log.setResponseTime(duration);

                // Assuming authentication is used; adjust accordingly
                if (httpRequest.getUserPrincipal() != null) {
                    log.setUserId(httpRequest.getUserPrincipal().getName());
                }

                // Save the log entry asynchronously
                logService.saveLog(log);
            }
		  }
        }
    }

    @Override
    public void destroy() {
        // Cleanup logic if needed
    }

    /**
     * Helper method to extract client IP address.
     * Considers X-Forwarded-For header in case of proxies.
     */
    private String getClientIp(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null){
            return request.getRemoteAddr();
        }
        return xfHeader.split(",")[0];
    }
}

spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true


// Example Using a Try-Catch Block: GetRequestLoggingFilter.java

// ... (imports)

@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
    long startTime = System.currentTimeMillis();

    // Proceed with the next filter or the target resource
    chain.doFilter(request, response);

    long duration = System.currentTimeMillis() - startTime;

    // Only log GET requests
    if (request instanceof HttpServletRequest) {
        HttpServletRequest httpRequest = (HttpServletRequest) request;

        if ("GET".equalsIgnoreCase(httpRequest.getMethod())) {
            HttpServletResponse httpResponse = (HttpServletResponse) response;

            GetRequestLog log = new GetRequestLog();
            log.setEndpoint(httpRequest.getRequestURI());
            log.setQueryParams(httpRequest.getQueryString());
            log.setClientIp(getClientIp(httpRequest));
            log.setUserAgent(httpRequest.getHeader("User-Agent"));
            log.setReferer(httpRequest.getHeader("Referer"));
            log.setResponseStatus(httpResponse.getStatus());
            log.setResponseTime(duration);

            // Fetch authenticated user
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.isAuthenticated()
                    && !"anonymousUser".equals(authentication.getPrincipal())) {
                log.setUserId(authentication.getName());
            }

            try {
                // Save the log entry asynchronously
                logService.saveLog(log);
            } catch (Exception e) {
                // Log the exception using your preferred logging framework
                // e.g., SLF4J, Log4j
                // This ensures that the logging failure is recorded
                LoggerFactory.getLogger(GetRequestLoggingFilter.class)
                             .error("Failed to log GET request", e);
            }
        }
    }
}


// GlobalExceptionHandler.java

package com.yourcompany.storyapi.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    // Handle IllegalArgumentException
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException ex) {
        ErrorResponse error = new ErrorResponse("Invalid Request", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    // Handle other exceptions
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllExceptions(Exception ex) {
        ErrorResponse error = new ErrorResponse("Internal Server Error", "An unexpected error occurred.");
        // Optionally log the exception details
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // ErrorResponse DTO
    public static class ErrorResponse {
        private String error;
        private String message;

        public ErrorResponse() {}

        public ErrorResponse(String error, String message) {
            this.error = error;
            this.message = message;
        }

        // Getters and Setters
        // ...
    }
}









